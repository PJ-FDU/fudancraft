# Cocos2d-x游戏引擎

## 概述

## 内存管理机制

## 更新调度机制

## 重要数据结构

### cocos2d::Ref类

### cocos2d::Layer类

### cocos2d::Sprite类

### cocos2d::TMXTiledMap类

### cocos2d::DrawNode类

### cocos2d::LabelBMFont类

# 战场场景

战场场景是FudanCraft游戏的核心部分，也是和用户交互的主要界面。

## 战场场景需求分析

作为一个交互性、娱乐性、竞技性较强的RTS游戏，FudanCraft的战场场景需要实现以下一些几项主要功能：

* 将战场地图和战场地图上地图单位的实时运动情况展现给用户；
* 允许用户通过鼠标移动或键盘按键移动视角，观察整个地图，并灵活切换视角，观察基地等关键位置；
* 允许用户通过鼠标的点击、拖框等操作完成选中单位、移动单位和下达攻击命令等游戏操作；
* 提供菜单，允许用户通过点击菜单创建单位；
* 显示金钱增减、单位被攻击、摧毁和最后的胜利提示等重要的游戏消息；
* 播放动感的背景音乐，给用户提供良好的视听体验


游戏场景的具体操作方法和交互模式在用户手册中有详细描述。

## 战场场景相关的数据结构

战场场景的逻辑主要在`class BattleScene`类中实现，与战场场景相关的类还有`class ControlPanel`等。

### BattleScene类

BattleScene类是战场场景的主要部分，包含战场地图、鼠标操作、金钱显示、游戏消息显示等功能部件，BattleScene类实现了这些功能部件的初始化和调度。

BattleScene直接继承自`cocos2d::Layer`，是一个完整的cocos2d图层，便于初始化、更新和场景切换。BattleScene类中重要的属性如下表所示：

| 变量名            | 类型                    | 结构   | 种类      | 初值      | 含义     |
| -------------- | --------------------- | ---- | ------- | ------- | ------ |
| player_id      | int                   | 普通变量 | private | 0       |        |
| socket_server  | SocketServer*         | 指针   | private | nullptr | 服务器套接字 |
| socket_client  | SocketClient*         | 指针   | private | nullptr | 客户端套接字 |
| battle_map     | cocos2d::TMXTiledMap* | 指针   | private | nullptr | 瓦片地图   |
| grid_map       | GridMap*              | 指针   | private | nullptr | 格点地图   |
| unit_manger    | UnitManager*          | 指针   | private | nullptr | 单位管理器  |
| control_panel_ | ControlPanel*         | 指针   | private | nullptr | 控制面板   |
| mouse_rect     | MouseRect*            | 指针   | private | nullptr | 鼠标选框   |
| money          | Money*                | 指针   | private | nullptr | 金钱     |
| notice         | Notice*               | 指针   | private | nullptr | 游戏提示   |
| msg_set        | GameMessageSet        | 类对象  | public  | 未初始化    | 游戏消息集  |

Battle类的重要方法如下：

* `static BattleScene* create(SocketClient* _socket_client, SocketServer* _socket_server);`按照cocos2d内存管理方式创建BattleScene对象，返回指向新对象的指针
* `virtual bool init(SocketClient* _socket_client, SocketServer* _socket_server);`初始化战场场景和内部的各个控件


* `void win();`通知战场场景游戏胜利结束，显示消息并禁止后续操作
* `void lose();`通知战场场景游戏以失败结束，显示消息并禁止后续操作
* `void update(float f) override;`战场场景的更新函数
* `bool onTouchBegan(cocos2d::Touch*, cocos2d::Event*)override;`触摸开始事件回调函数
* `void onTouchMoved(cocos2d::Touch*, cocos2d::Event*)override;`触摸移动事件回调函数
* `void onTouchEnded(cocos2d::Touch*, cocos2d::Event*)override;`触摸结束事件回调函数
* `void onKeyPressed(cocos2d::EventKeyboard::KeyCode, cocos2d::Event *) override;按键事件回调函数`
* `void scrollMap();`地图滚动函数
* `void focusOnBase();`将视角集中到当前用户的基地
* `void destroyReward(int destroyed_type);`获取击毁地方单位的奖励
* `void menuBackCallback(cocos2d::Ref* pSender);`

### MouseRect类

MouseRect类是用户通过触摸移动或按住拖动鼠标的操作，在地图上拖动出矩形这一功能的抽象。MouseRect需要实现在地图移动和视角变化时灵活变化形状的功能。

MouseRect继承自`cocos2d::DrawNode`，`cocos2d::DrawNode`是cocos2d引擎提供的基础绘图类，可以灵活地画出空心、实心矩形多边形等基础形状。MouseRect的主要属性有：

| 变量名         | 类型             | 结构   | 种类     | 初值   | 含义     |
| ----------- | -------------- | ---- | ------ | ---- | ------ |
| touch_start | cocos2d::Point | 类对象  | public | 未初始化 | 触摸开始点  |
| touch_end   | cocos2d::Point | 类对象  | public | 未初始化 | 触摸结束点  |
| start       | cocos2d::Point | 类对象  | public | 未初始化 | 选框开始端点 |
| end         | cocos2d::Point | 类对象  | public | 未初始化 | 选框结束端点 |

MouseRect的重要方法有：

* `void update(float f) override;`鼠标矩形的更新函数

### Money类

Money类用于存储和管理用户当前持有的金钱，并在战场场景中更新和显示金钱的数值。

Money类继承自`cocos2d::LabelBMFont`，便于金钱数值的显示和快速更新。

Money类的重要属性如下：

| 变量名     | 类型   | 结构   | 种类      | 初值                | 含义     |
| ------- | ---- | ---- | ------- | ----------------- | ------ |
| money   | int  | 普通变量 | private | 0                 | 当前金钱数值 |
| timer   | int  | 普通变量 | private | 0                 | 计时器    |
| inc_prd | int  | 普通变量 | private | 宏MONEY_INC_PERIOD | 金钱增加周期 |
| inc_amt | int  | 普通变量 | private | 宏MONEY_INC_AMOUNT | 金钱增加数量 |

Money类的重要方法如下：

* `void update(float f) override;`金钱自动更新函数，使金钱每隔一段时间增加一定数值
* `bool init() override;`金钱初始化函数，初始化金钱为某一固定数值，读取BM字体集，并进行显示
* `void updateMoneyDisplay();`更新金钱的显示
* `bool checkMoney(int cost) const;`检查金钱是否足够
* `void spendMoney(int cost);`花掉数值等于cost的金钱，即金钱数量减少cost
* `void increaseMoney(int amount);`金钱数量增加amount

### Notice类

Notice类用于显示重要的游戏提示。Notice类实现了游戏提示的更新、定时消失和固定显示。

Notice类继承自`cocos2d::LabelBMFont`，便于游戏提示的显示和快速更新。

Notice类的重要属性如下：

| 变量名      | 类型   | 结构   | 种类      | 初值   | 含义     |
| -------- | ---- | ---- | ------- | ---- | ------ |
| ntc_life | int  | 普通变量 | private | 0    | 提示显示寿命 |
| timer    | int  | 普通变量 | private | 0    | 计时器    |

Notice类的重要方法如下：

* `void update(float f) override;`游戏提示的更新函数，实现游戏提示的定时消失
* `void displayNotice(std::string ntc, int _ntc_life);`显示提示函数，显示字符串ntc对应的游戏提示，定时_ntc_life后消失
* `void displayNotice(std::string ntc);`显示提示函数的重载，显示字符串ntc对应的游戏提示，固定显示不消失
* `bool init() override;`游戏提示初始化，初始提示为"Welcome to FudanCraft!"，读取BM字体集，并进行显示

### ControlPanel类

## 战场场景相关的重要算法

### 视角移动与地图滚动的实现

### 鼠标选框的实现

鼠标选框是RTS游戏中常见的交互方式，是指用户按压鼠标或触摸板并移动时，在屏幕上拖出一个矩形框，对框中的单位进行选中操作。需要注意的是，鼠标选框应该依附在地图上，随着地图移动；当视角变化、地图滚动时，鼠标选框应随之变形，进而覆盖更大的范围。

鼠标选框的功能主要在MouseRect类中实现，接收BattleScene类传递的鼠标（触摸）消息，依附在TMXTiledMap类的对象battle_map战场地图上显示。

具体的顺序图如下所示：

```mermaid
sequenceDiagram
	User->>+BattleScene: Start Game
    BattleScene->>+MouseRect: Initialize  
    MouseRect-->>-BattleScene: Pointer to new object
    BattleScene->>TiledMap: Add child
    User->>BattleScene: Touch start
    BattleScene->>+MouseRect: Set touch start point
    User->>BattleScene: Touch move
    BattleScene->>MouseRect: Set touch end point
    MouseRect->>+TiledMap: Check battle map position
    TiledMap-->>-MouseRect: Return battle map position
    MouseRect->>MouseRect: Update
    User->>BattleScene: Touch end
    BattleScene->>MouseRect: Query select rect
    MouseRect->>BattleScene: Return select rect
    User->>-BattleScene: Quit Game
    
```

当鼠标按压移动时，BattleScene会将MouseRect添加到自动更新update队列中。cocos2d引擎的场景导演会定时调用`MouseRect::update()`更新函数，在更新函数中MouseRect会查询战场地图的位置，实现鼠标选框的变形显示，具体关系如下图所示：

![MouseRect原理图](F:\Programs\Test C++\软件设计与开发\fudancraft\fudancraft\documents\MouseRect原理图.jpg)

当视角移动、地图滚动时，鼠标选框的端点应该是当前鼠标拖动向量和地图滚动向量的差，在update()函数中定时进行运算，就可以实现鼠标选框的连续变化。

# 地图

地图是RTS游戏的关键部分，单位的创建、移动都与地图密切相关。在FudanCraft中，实际上有两层地图：一层是用于显示的瓦片地图，直接采用了`coocos2d::TMXTiledMap`；另一层是用于运算的逻辑（格点）地图，主要由`class GridMap`类实现。两层地图结合，实现了单位运动的实时显示、碰撞检测、寻路查找等功能。

## 地图需求分析

作为一个复杂性较强的RTS游戏，FudanCraft的地图需要满足以下几项用户需求：

* 提供较大的地图，使得3到4个用户同时进行游戏时都有自由的游戏空间，可以进行大型、激烈的战斗
* 提供复杂的地形，模拟真实的战场情况，使得单位在地图上运动的方式更加复杂多变，提高游戏的挑战性和娱乐性
* 地图上要提供初始的基地、单位等信息，用于场景和单位的初始化，使得游戏初期就能进行激烈的交锋

## 地图的设计思路

由于FudanCraft游戏的地图较大，在显示层我们采用了cocos2d引擎提供的瓦片地图类`cocos2d::TMXTiledMap`。瓦片地图是将整个地图划分为若干个小块，采用小纹理图片连续贴图，这样可以大大提高显示的性能。

在逻辑层，我们设计了与瓦片地图对应的格点地图GridMap，将地图划分为128x128个大小相等的正方形，每个正方形对应瓦片地图中的一个瓦片。每个单位在移动时可以连续地平滑移动，但都会静止在一个格点的中央附近。每个格点同时只能被一个单位占据，这样就避免了单位的重叠。单位的移动、攻击、搜索敌人等操作也都是通过格点地图进行的。格点地图的实现主要在GridMap类中，将在地图的相关算法一节中详细叙述。瓦片地图与格点地图的关系如下图所示：



![瓦片地图与格点地图关系图](F:\Programs\Test C++\软件设计与开发\fudancraft\fudancraft\documents\瓦片地图与格点地图关系图.jpg)

瓦片地图用于显示，提供了各种瓦片的信息，地形能否通过的信息以及初始化单位的信息；格点地图用于运算，储存了格点是否被占据的信息以及占据单位ID的信息。

## 地图相关的数据结构

### GridPoint类

GridPoint类是一个简单结构，用来表示格点坐标，提供加、减、相等等运算符重载，类似于`cocos2d::Point`，但Point的坐标是浮点数，而GridPoint的格点坐标用整数表示。GridPoint类的属性如下：

| 变量名  | 类型   | 结构   | 种类     | 初值   | 含义       |
| ---- | ---- | ---- | ------ | ---- | -------- |
| x    | int  | 普通变量 | public | 0    | 格点的整数横坐标 |
| y    | int  | 普通变量 | public | 0    | 格点的整数纵坐标 |

重要的方法如下：

* `bool operator==(const GridPoint& gp2) const;`相等运算符重载
* `friend GridPoint operator+(const GridPoint& gp1, const GridPoint& gp2);加运算符重载`
* `friend GridPoint operator-(const GridPoint& gp1, const GridPoint& gp2);`减运算符重载
* `GridPoint getDirectionVector();`获得方向向量

### GridPath类型

GridPath类型表示一系列格点坐标构成的格点路径，用于单位的寻路移动。实际上是`std::vector<GridPoint>`的一个重定义，即`typedef std::vector<GridPoint>  GridPath;`。

### GridSize类

GridSize类用于表示一个格点矩形的大小，类似于`cocos2d::Size`，但Size的长宽是浮点数，而GridSize的长宽用整数表示。GridSize类的属性如下：

| 变量名    | 类型   | 结构   | 种类     | 初值   | 含义      |
| ------ | ---- | ---- | ------ | ---- | ------- |
| width  | int  | 普通变量 | public | 0    | 格点矩形的宽度 |
| height | int  | 普通变量 | public | 0    | 格点矩形的高度 |

重要方法如下：

* `friend GridSize operator/(const GridSize& gz, int s);`除运算符重载，将长宽都整除系数s

### GridRect类

GridRect类用于表示一个格点矩形，类似于`cocos2d::Rect`，但GridRect的端点和大小是用GridPoint 和GridSize表示的。GridRect类的属性如下：

| 变量名  | 类型        | 结构   | 种类     | 初值              |
| ---- | --------- | ---- | ------ | --------------- |
| gp   | GridPoint | 类对象  | public | GridPoint(0, 0) |
| size | GridSize  | 类对象  | public | GridSize(0, 0)  |

重要方法如下：

* `GridRect(GridPoint _gp = GridPoint(), GridSize _size = GridSize()) : gp(_gp), size(_size) {}`构造函数，由左下角的端点和矩形大小构造一个矩形

### GridMap类

GridMap类是格点地图，用于寻路、格点占据判断、临近单位搜索、临近空位搜索等逻辑运算。GridMap类的属性如下：

| 变量名         | 类型                              | 结构   | 种类      | 初值   | 含义                |
| ----------- | ------------------------------- | ---- | ------- | ---- | ----------------- |
| gmap        | std::vector\<std::vector\<int>> | 类对象  | private | 未初始化 | 格点层，记录格点是否被占据     |
| umap        | std::vector\<std::vector\<int>> | 类对象  | private | 未初始化 | 单位ID层，记录占据格点的单位ID |
| map_width   | int                             | 普通变量 | private | 未初始化 | 地图宽度（格点数）         |
| map_height  | int                             | 普通变量 | private | 未初始化 | 地图高度（格点数）         |
| grid_width  | int                             | 普通变量 | private | 未初始化 | 格点宽度（像素）          |
| grid_height | int                             | 普通变量 | private | 未初始化 | 格点高度（像素）          |
| offset_vec  | cocos2d::Vec2                   | 类对象  | private | 未初始化 | 偏移向量              |

重要方法如下：

* `bool checkPointInMap(const GridPoint& gp) const;`检查格点gp是否在格点地图范围内，避免越界
* `bool checkPosition(const GridPoint& gp);`检查格点gp是否被占据
* `bool checkPosition(const GridRect& grec);`检查格点矩形grec是否被占据
* `bool occupyPosition(int id, const GridPoint& pos, bool occupy_grid = true);`尝试占据格点pos
* `bool occupyPosition(int id, const GridRect& grec, bool occupy_grid = true);`尝试占据格点矩形grec
* `void leavePosition(const GridPoint& pos, bool occupy_grid = true);`离开格点pos
* `void leavePosition(const GridRect& grec, bool occupy_grid = true);`离开格点矩形grec
* `int getUnitIDAt(const GridPoint& gp) const;`获取格点gp处单位ID
* `std::vector<int> getUnitIDAt(const GridRect& range) const;`获取格点矩形range范围内所有单位ID
* `cocos2d::Point getPoint(const GridPoint& gp);`得到格点gp对应的点坐标
* `GridPoint getGridPoint(const cocos2d::Point& p);`得到点p对应的格点坐标
* `cocos2d::Point getPointWithOffset(const GridPoint& gp);`得到格点gp对应的点坐标（考虑格点带来的偏移）
* `GridPoint getGridPointWithOffset(const cocos2d::Point& p);`得到点p对应的格点坐标（考虑格点带来的偏移）
* `std::vector<std::vector<int>>& getLogicalGridMap();`得到格点层的逻辑地图
* `GridPoint findFreePositionNear( const GridPoint& gp);`查找距格点gp最近的空闲的格点
* `bool hasApproached(const cocos2d::Point& cur_fp, const GridPoint& dest_gp);`检查点cur_fp是否靠近格点dest_gp中央

## 地图相关的重要算法

### 格点的检查、占据与离开

格点层gmap是一个128x128的二维整形vector对象，记录了每个格点是否被占据的信息，被占据的格点记为1，没有被占据的格点记为0。单位ID层umap也是一个128x128的二维整形vector对象，记录了占据每个格点的单位ID，没有被占据的格点数值为0。GridMap类提供了检查格点、占据格点和离开格点的一系列API，与单位类Unit交互，实现了碰撞检测、障碍物信息查询等功能。

格点检查函数checkPosition()包括一系列重载函数，用于检测格点是否可以占据，如果输入变量是一个GridPoint类型的格点gp，首先要检测gp是否越界，如果不越界则检查gmap中对应坐标的位置是否为0，如果为0则该格点当前没有被占据，返回真；否则说明该格点已经被占据，返回假；如果gp越界，则直接返回假。如果输入变量是一个GridRect类型的格点矩形grec，则需要逐一检查grec内部每一个格点是否被占据，如果都没有被占据才返回真，否则返回假。

格点占据函数occupyPosition()也包括两个重载函数，分为两种情况，由bool参数occupy_grid确定：如果occupy_grid为真，则既占据gmap也占据umap；如果occupy_grid为假，则只占据umap而不占据gmap。这是因为有些单位在移动过程中并不真正地占据格点，比如战斗机单位，但需要在umap中添加ID以便于搜索敌人、自动攻击等功能的实现。默认occupy_grid参数为真。格点占据函数的流程图如下所示：

![格点占据函数流程图](格点占据函数流程图.png)

如果输入参数是GridRect类型的grec，那么程序会先调用checkPosition(grec)检查这个格点矩形是否被占据，如果没有被占据则逐一占据这个矩形中的所有格点。

格点离开函数leavePosition()也是一系列重载函数，与occupyPosition()相反，用于消除gmap和umap上占据的格点。也分为occupy_grid为真和为假的两种情况。

### 邻近空位搜索算法

单位创建和寻路搜索过程中，常常出现当前设定的目标位置已被占据，无法到达的情况，这时候就需要搜索目标位置附近的空闲位置。在	`GridPoint GridMap::findFreePositionNear(const GridPoint& origin_gp)`函数中实现了格点origin_gp邻近空闲位置的搜索功能。

如果要找到离origin_gp最近的空闲格点，需要按照圆周逐一遍历origin_gp附近的格点，并逐渐增大圆周的半径。但这种方法需要用到复杂的浮点运算，效率不高；而邻近空位搜索算法的调用频率较高，不适合用这种方法。

也可以采用列表的方法，把邻近格点的偏移向量保存在一个数组或vector中，如{{0, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 0}, ......}。但这种方法保存的格点偏移向量数量有限，如果在这些格点中没有找到空闲位置，程序就无法做出正确的反应。而在RTS游戏中，常常出现巨大的障碍物或很多单位聚在一起的情况，如果无法找到空位单位的移动就会出现问题，因此对邻近空位搜索算法的可靠性要求较高。

我们最后采用的是一种“菱形查找”的方法。按照菱形的轮廓逐一遍历origin_gp周围的格点，并逐渐增大菱形的尺寸。具体的遍历顺序如下图所示：

|         |           |           |           |         |         |        |
| ------- | --------- | --------- | --------- | ------- | ------- | ------ |
|         |           |           | (0, 3)    |         |         |        |
|         |           | (-1, 2)   | (0, 2)    | (1, 2)  |         |        |
|         | (-2, 1)   | (-1, 1)   | (0, 1)    | (1, 1)  | (2, 1)  |        |
| (-3, 0) | (-2, 0)   | (-1, 0)   | origin_gp | (1,  0) | (2, 0)  | (3, 0) |
|         | (-2,  -1) | (-1,  -1) | (0, -1)   | (1, -1) | (2, -1) |        |
|         |           | (-1,  -2) | (0, -2)   | (1, -2) |         |        |
|         |           |           | (0, -3)   |         |         |        |

用数学的方法表示就是遍历满足|x| + |y| = i的所有(x, y)，i = 1, 2, 3, ...，检查origin_gp + (x, y)是否空闲。菱形查找得到的空闲点可能不是离origin_gp最近的，但可以正确查找到距origin_gp较近的空闲位置，并且查找效率较高，查找的范围无限大。最后在游戏中使用的效果较好。

# 单位

单位是FudanCraft游戏的重要组成部分，也是很有特色的内容。单位的实现主要分为三部分：单位本身、单位的附加效果、单位管理器。

## 单位的需求分析

* 单位需要接受鼠标操作或网络模块传递的信息，实现创建、移动、攻击等基本功能
* 单位要有寻路能力，可以自动避开障碍地形，多单位共同移动时不会重合，途中遇到障碍物时会自动重新寻路，沿最短路径到达指定地点
* 多单位可以共同移动、寻路、攻击，实现大军团作战的效果，使游戏对抗更加激烈
* 需要有多种特色单位，单位的移动、攻击方式各具特色，实现多兵种协同作战
* 还有具有特殊功能的建筑，使游戏的玩法复杂多变，富有特色
* 各种单位的生命值、攻击力、价格等数值设定互不相同，使游戏的策略性更强
* 单位还具有追踪敌人、自动搜索敌人、自动攻击等高级功能，减少用户的操作负担
* 单位的有血条显示、攻击弹道等附加效果，使用户能够清楚地了解单位的状态
* 单位受伤、被击毁、基地被摧毁都产生游戏提示，提醒用户进行防御
* 单位创建、被摧毁、基地被攻击产生音效，提示用户的同时提升用户的视听感受

## 单位相关的数据结构

### Unit类

Unit类是各种单位的基类，预留了单位的各项数值属性，设置了创建、移动、攻击等基础接口，实现了寻路和重新寻路策略， 完成了自动搜索敌人、自动攻击等高级功能的实现，添加了血条、粒子效果、提示、音效等和用户交互的控件。Unit类的重要属性如下：

| 变量名          | 类型             | 结构   | 种类      | 初值      | 含义    |
| ------------ | -------------- | ---- | ------- | ------- | ----- |
| id           | int            | 普通变量 | public  | 未初始化    |       |
| camp         | int            | 普通变量 | public  | 0       | 阵营    |
| z_index      | int            | 普通变量 | public  | 未初始化    | z轴高度  |
| unit_manager | UnitManager*   | zhi  |         |         |       |
|              |                |      |         |         |       |
|              |                |      |         |         |       |
|              |                |      |         |         |       |
|              |                |      |         |         |       |
|              |                |      |         |         |       |
| notice       | Notice*        | 指针   | private | nullptr | 游戏提示  |
| msg_set      | GameMessageSet | 类对象  | public  | 未初始化    | 游戏消息集 |
|              |                |      |         |         |       |
|              |                |      |         |         |       |
|              |                |      |         |         |       |
|              |                |      |         |         |       |
|              |                |      |         |         |       |
|              |                |      |         |         |       |
|              |                |      |         |         |       |
|              |                |      |         |         |       |